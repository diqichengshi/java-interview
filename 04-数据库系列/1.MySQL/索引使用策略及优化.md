## 1. 示例数据库

MySQL的优化主要分为结构优化(Scheme optimization)和查询优化(Query optimization)。本章讨论的高性能的索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。

为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图（引用自MySQL官方手册）：

![img](file:///C:\Users\LIUSHU~1\AppData\Local\Temp\msohtmlclip1\01\clip_image002.gif)

官方文档中关于此数据库的页面https://github.com/datacharmer/test_db。里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的MySQL可以参考文中内容。

## 2. 最左前缀原理与相关优化

高效使用索引的首要条件是知道什么样的查询会使用到什么样的索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。

这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组<a1,a2…,an>，其中各个元素均为数据表的一列，实际上要严格定义索引所需要用到的关系代数，但是这里不想讨论太多关于关系代数的问题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引数据元素为1的特例。

以employees.titles表为例，下面先查看其上都有哪些索引：![img](file:///C:\Users\LIUSHU~1\AppData\Local\Temp\msohtmlclip1\01\clip_image004.jpg)

从结果中可以到titles表的主索引为<emp_no, title, from_date>。

### 2.1.全列匹配

目前只要M'y'ISAM引擎支持。其可以在创建表、修改表、创建索引时使用，目前只有CHAR、VARCHAR、TEXT列上可以创建全文索引。值得一提的是，在数据量较大的时候，现将数据放入一个没有全文索引的表中，然后再用create index创建全文索引，要比先创建全文索引然后再将数据写入时速度快很多。



![img](file:///C:\Users\LIUSHU~1\AppData\Local\Temp\msohtmlclip1\01\clip_image006.jpg)

很明显，当按照索引中所有列进行精确匹配的(这里精确匹配指“=”或“IN”匹配)时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where字句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：



![img](file:///C:\Users\LIUSHU~1\AppData\Local\Temp\msohtmlclip1\01\clip_image006.jpg)

效果是一样的。

### 2.2.最左前缀匹配





![img](file:///C:\Users\LIUSHU~1\AppData\Local\Temp\msohtmlclip1\01\clip_image008.jpg)

当查询条件精确匹配索引的左边连续一个或几列时，如<emp_no>或<emp_no,title>，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。



### 2.3.查询条件用到了索引中列的精确匹配，但是中间某个条件未匹配







![img](file:///C:\Users\LIUSHU~1\AppData\Local\Temp\msohtmlclip1\01\clip_image010.jpg)

此索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法与左前缀连接，因此需要对结果进行扫描过滤from_date(这里由于emp_no唯一，所以不存在扫描)。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引<emp_no,from_date>，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。

首先我们看下title一共有几种不同的值：



只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：



![img](file:///C:\Users\LIUSHU~1\AppData\Local\Temp\msohtmlclip1\01\clip_image012.jpg)

这里key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key，看下两种查询的性能比较。



'填坑'后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。

### 2.4.查询条件没有指定索引的第一列



![img](file:///C:\Users\LIUSHU~1\AppData\Local\Temp\msohtmlclip1\01\clip_image014.jpg)

由于不是最左前缀，索引这样的查询显然用不到索引。

### 2.5.匹配某列的前缀字符串



![img](file:///C:\Users\LIUSHU~1\AppData\Local\Temp\msohtmlclip1\01\clip_image016.jpg)

此时可以用到索引，但是如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀。

### 2.6.范围查询



![img](file:///C:\Users\LIUSHU~1\AppData\Local\Temp\msohtmlclip1\01\clip_image018.jpg)

范围列可以使用到索引(必须是最左前缀)，但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。



![img](file:///C:\Users\LIUSHU~1\AppData\Local\Temp\msohtmlclip1\01\clip_image020.jpg)

可以看到索引对第二个范围索引无能为力。这里需要特别说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了' between'并不意味着就是范围查询，例如下面的查询：



![img](file:///C:\Users\LIUSHU~1\AppData\Local\Temp\msohtmlclip1\01\clip_image022.jpg)

看起来是用了两个范围查询，但是作用于emp_no上的' between'实际上相当于 'in '，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎的区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。

### 2.7.查询条件中含有函数或表达式

很不幸，如果查询中含有函数或表达式，则MySQL不会为这列使用索引多值匹配和范围匹配。



![img](file:///C:\Users\LIUSHU~1\AppData\Local\Temp\msohtmlclip1\01\clip_image024.jpg)

虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：



![img](file:///C:\Users\LIUSHU~1\AppData\Local\Temp\msohtmlclip1\01\clip_image026.jpg)

显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。

## 3.索引选择性和前缀索引

既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。

第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没有必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个每个人有每个人的看法，我个人的经验是以2000作为分界线，记录数不超过2000可以考虑不建索引，超过2000条可以酌情考虑索引。

另一种不建议建索引的情况是索引的选择性较低。所谓所以的选择性(Selectivity)，是指不重复的索引值(也叫基数，Cardinality)与表记录数(#T)的比值：

Index Selectivity = Cardinality / #T

虽然选择性的取值范围为(0,1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：



title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。

有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到即使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。

从下图可以看到employees表只有一个索引<emp_no>，那么如果我们想按名字搜索一个人，就只能全表扫描了：



![img](file:///C:\Users\LIUSHU~1\AppData\Local\Temp\msohtmlclip1\01\clip_image028.jpg)

如果频繁的按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建<first_name>或<first_name, last_name>，看下两个索引的选择性：



<first_name>显然选择性太低，<first_name, last_name>选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法吗？可以考虑用first_name和last_name的前几个字符建立索引，例如<first_name,left(last_name,3)>,看看其选择性：



选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：



这时选择性已经很理想了，而这个索引的长度只有18，比<first_name,last_name>短了接近一半，我们把这个前缀索引建上：



此时再执行一遍按名字查询，比较分析一下与建索引前的结果：

性能的提升是显著的，查询速度提高了120多倍。

前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index(即当索引本身包含查询所需的全部数据时，不能访问数据文件本身)。

## 4.InnoDB的主键选择与插入优化

在使用InnoDB存储引擎时，如果没有特别需要，请永远使用一个与业务无关的自增字段作为主键。

经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。无论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。

上文讨论过InnoDB的索引实现，InnoDB使用聚合索引，数据记录本身被存于主索引(一颗B+Tree)的叶子节点上。这就要求同一个叶子节点内(大小为一个内存页)的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子(InnoDB默认为15/16)，则开辟一个新的页(节点)。

如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页，如下图所示：

![img](file:///C:\Users\LIUSHU~1\AppData\Local\Temp\msohtmlclip1\01\clip_image030.gif)
 此时MySQL不得不为了将新的新纪录插到合适位置而移动数据，甚至目标页面可能已经被写回到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

因此，只要可以，请尽量在InnoDB上采用自增字段做主键。

 