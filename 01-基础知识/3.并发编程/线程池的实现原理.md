## 1.线程的好处

线程是稀缺资源，如果被无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，合理的使用线程池对线程进行统一分配、调优和监控，有以下好处：

1.降低资源消耗。

2.提高响应速度。

3.提高线程的可管理性。

Java1.5中引入的Executor框架把任务的提交和执行进行解耦，只需要定义好任务，然后提交给线程池，而不用关心该任务是如何执行、被哪个线程执行，以及什么时候执行。

## 2.线程池的参数

Executor是Java线程池的工厂类，通过它可以快速初始化一个符合业务需求的线程池，如Executors.newFixedThreadPool方法可以生成一个拥有固定线程数的线程池。

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

其本质是通过不同的参数初始化一个ThreadPoolExecutor对象，具体参数描述如下：

### 2.1.corePoolSize

线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的线程被保存到阻塞队列中，等待被执行完；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。

### 2.2.maximumPoolSize

线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize。

### 2.3.keepAliveTime

线程空闲时的存活时间，即当前线程没有任务执行时，继续存活的时间；默认情况下，该参数只是在线程数大于corePoolSize时才有用；

### 2.4.unit

keepAliveTime的单位；

### 2.5.workQueue

用来保存等待被执行的任务的阻塞队列，且任务必须实现Runnable接口，在JDK中提供了如下阻塞队列：

1.ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；

2.LinkedBlockingQueue：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue

3.SynchronousQueue：一个不存储元素的阻塞队列(**内部没有数据缓存空间**)，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue；

4.PriorityBlockingQueue：具有优先级的无界阻塞队列。

### 2.6.threadFactory

创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。

```java
DefaultThreadFactory() {
    SecurityManager s = System.getSecurityManager();
    group = (s != null) ? s.getThreadGroup() :
                          Thread.currentThread().getThreadGroup();
    namePrefix = "pool-" +
                  poolNumber.getAndIncrement() +
                 "-thread-";
}
```

### 2.7.handler

线程池的保存策略，当线程队列满了，且没有空闲的工作线程，如果继续提交任务，必须采用一直策略处理该任务，线程池提供了4种策略：

1.AbortPolicy：直接抛出异常，默认策略。

2.CallerRunsPolicy：用调用者所在的线程来执行任务。

3.DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务。

4.DiscardPolicy：直接丢弃任务。

## 3.Exectors

Exectors工厂类提供了线程池的初始化接口，主要有如下几种：

### 3.1.newFixedThreadPool

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

初始化一个指定线程数的线程池，其中corePoolSize = maximumPoolSize，**使用LinkedBlockingQueue作为阻塞队列**，不过当线程池没有可执行任务时，也不会释放线程。

### 3.2.newCachedThreadPool

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

1.初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Interget.MAX_VALUE，即2147483647，**内部使用SynchronousQueue作为阻塞队列**。

2.和newFixedThreadPool创建的线程池不同，newCachedThreadPool在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销。

所以，使用该线程池时，一定要注意控制并发的任务数，否则创建大量的线程可能会导致验证的性能问题。

### 3.3.newSingleThreadExecutor

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所有提交的任务的顺序执行，**内部使用LinkedBlockingQueue作为阻塞队列**。

### 3.4.newScheduledThreadPool

```java
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
```

初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。

## 4.实现原理

除了newScheduledThreadPool的内部实现特殊一点之外，其它几个线程池都是基于ThreadPoolExecutor类实现的。

### 4.1.线程池内部状态

```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3;
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

// runState is stored in the high-order bits
private static final int RUNNING    = -1 << COUNT_BITS;
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;

// Packing and unpacking ctl
private static int runStateOf(int c)     { return c & ~CAPACITY; }
private static int workerCountOf(int c)  { return c & CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

其中的AtomicInteger变量ctl的功能非常强大：利用低29位表示线程池中的线程数，通过高3位表示线程池的允许状态。

1.RUNNING：-1 << COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，通过高3位表示线程池的运行状态。

2.SHUTDOWN：0 << COUNT_BITS，即高3位000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务。

3.STOP：1 << COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务。

4.TIDYING：2 << COUNT_BITS，即高3位为010。

5.TERMINATED：3 << COUNT_BITS，即高3位为011。

### 4.2.任务提交

线程池框架提供了两种方式提交任务，根据不同的业务需求选择不同的方式。

Executor.execute()：通过Executor.execute()方法提交的任务，必须实现Runnable接口，该方式提交的任务不能获取返回值，因此无法判断任务是否执行成功。

ExecutorService.submit()：通过ExecutorService.submit()方法提交的任务，可以获取任务执行完的返回值。

### 4.3.任务执行

当向线程池中提交一个任务，线程池会如何处理该任务？

#### 4.3.1.线程池execute实现(面试)

```java
int c = ctl.get();
if (workerCountOf(c) < corePoolSize) {
    if (addWorker(command, true))
        return;
    c = ctl.get();
}
if (isRunning(c) && workQueue.offer(command)) {
    int recheck = ctl.get();
    if (! isRunning(recheck) && remove(command))
        reject(command);
    else if (workerCountOf(recheck) == 0)
        addWorker(null, false);
}
else if (!addWorker(command, false))
    reject(command);
```

具体的执行流程如下：

1.workerCountOf()方法根据ctl的低29位，得到线程池的当前线程数，如果线程数小于corePoolSize，则执行addWorker()方法创建新的线程执行任务，否则执行步骤2。

2.如果线程池处于RUNNING状态，且把提交的任务成功放入阻塞队列，则执行步骤3，否则执行步骤4。

3.再次检查线程池的状态，如果线程池没有RUNNING，且成功从阻塞队列中删除任务，则执行reject()方法处理任务。

4.执行addWorker方法创建新的线程执行任务，如果addWorker()执行失败，则执行reject()方法处理任务。

#### 4.3.2.addWorker实现(理解)

从方法executer()的实现可以看出：addWorker()主要负责创建新的线程并执行任务，代码实现如下：

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;

        for (;;) {
            int wc = workerCountOf(c);
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }

    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());

                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

这只是addWorker()方法实现的前半部分：

1.判断线程池的状态，如果线程池的状态值大于或等于SHUTDOWN，则不处理提交的任务，直接返回。

2.通过参数core判断当前需要创建的线程是否为核心线程，如果core为true，且当前线程数小于corePoolSize，则跳出循环，开始创建新的线程。

#### 4.3.3.Worker类实现(理解)

线程池的工作线程通过Woker类实现，在ReentrantLock锁的保证下，把Woker实例插入到HashSet后，并启动Woker中的线程，其中Worker类设计如下：

1、继承了AQS类，可以方便的实现工作线程的中止操作；

2、实现了Runnable接口，可以将自身作为一个任务在工作线程中执行；

3、当前提交的任务firstTask作为参数传入Worker的构造方法；

```java
Worker(Runnable firstTask) {
    setState(-1); // inhibit interrupts until runWorker
    this.firstTask = firstTask;
    this.thread = getThreadFactory().newThread(this);
}
```

从Worker类的构造方法可以实现：线程工厂在创建线程thread时，将Worker实例本身this作为参数传入，**当执行start()方法启动线程thread时，本质是执行Worker的runWorker()方法。**

#### 4.3.4.runWorker实现(理解)

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```

runWorker方法是线程池的核心：

1.线程启动之后，通过unlock()方法释放锁，设置AQS的state为0，表示运行中断。

2.获取第一个任务firstTask，执行任务的run()方法，不过执行任务之前，会进行加锁操作，任务执行完会释放锁。

3.在执行任务的前后，可以根据业务场景自定义的beforeExecute()和afterExecute()方法。

4.firstTask执行完成之后，通过getTask()方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask()方法会被阻塞并挂起，不会占用cpu资源。

#### 4.3.5.getTask()实现(理解)

```java
private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // Are workers subject to culling?
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```

整个getTask操作在自旋下完成：

1、workQueue.take：如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务，并执行；

2、workQueue.poll：如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null；

所以，线程池中实现的线程可以一直执行由用户提交的任务。