## 1.何为悲观锁和乐观锁

乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。

### 1.1.悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据的时候就会阻塞直到它拿到说(**共享资源每次只给一个线程使用，其他线程等待，用完后再把资源转让给其他线程**)。传统的数据库里面就用到了很多这种锁机制，比如行锁、表锁等，读锁、写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

### 1.2.乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。**乐观锁适用于多读的应用类型，这样可以提供吞吐量**，像数据库提供的类似于**write_condition机制**，其实都是提供的乐观锁。在Java中java.util.concurent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

### 1.3.两种锁的使用场景

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像**乐观锁适用于写比较少的情况(多读场景)**，即冲突真的很少发生的情况，这样可以省去锁的开销，增加系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，就会导致上层应用不断的retry，这样反倒是降低了性能，所以**一般多写的场景下用悲观锁就比较适合。**

## 2.乐观锁的两种实现方式

乐观锁一般会采用版本号机制或CAS算法实现。

### 2.1.版本号机制

一般是在数据表中加上一个版本号version字段，表示数据被修改的次数，当数据被修改是，version值加1.当线程A要更新数据值时，在读取的时候也会读取version值，在提交更新时，若刚才读取到version值与数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

**举一个简单的例子：**假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段( balance )为 $100 。

1. 操作员 A 此时将其读出(version=1)，并从其帐户余额中扣除 $50($100-$50) 。
2. 在操作员 A 操作的过程中，操作员B 也读入此用户(version=1)，并从其帐户余额中扣除 $20 ($100-$20 )。
3. 操作员 A 完成了修改工作，将数据版本号加一(version=2)，连同帐户扣除后余额（ balance=$50)，提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。
4. 操作员 B 完成了操作，也将版本号加一(version=2)试图向数据库提交数据(balance=$80)，但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。

这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。

### 2.2.CAS算法

即compare and swap(**比较与交换**)，是一种有名的**无锁算法**，无锁编程，即在无锁的情况下实现所线程之间的变量同步，也就是在没有线程阻塞的情况下实现变量的同步，所以也叫非阻塞同步(Non-blocking Synchoronized)。

**CAS算法涉及三个操作数：**

1.需要读写的内存值V。

2.进行比较的值A。

3.拟写入的新值B。

当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作(比较和替换是一个原子操作)。一般情况下是一个**自旋操作**，即**不断的重试**。

关于自旋锁，大家可以看一下这篇文章，非常不错：[《 面试必备之深入理解自旋锁》](https://blog.csdn.net/qq_34337272/article/details/81252853)

## 3.乐观锁的缺点

### 3.1.ABA问题

如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查它让然是A值，那就能说明它的值没有被其它线程修改过吗？很明显不能，因为这段时间内它的值有可能被改为了其他值，然后又改回A，那么CAS操作就会误认为它从来没有被人修改过。这个问题就被称为CAS操作的ABA问题。

JDK1.5以后的AtomicStampedReference类就提供了这种能力，其中的compareAndSet()方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设定为给定的更新值。

### 3.2.循环时间长开销大

**自旋CAS(也就是不成功就一直循环执行直到成功)如果长时间不成功，会给CPU带来非常大的执行开销。**如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行命令(de-pipeline)，使CPU不会消耗更多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突(memory order violation)而引起CPU流水线被清空，从而提高CPU的执行效率。

### 3.3.只能保证一个共享变量的原子操作

CAS只对单个共享变量有效，当操作涉及跨多个共享变量时CAS无效，但是从JDK1.5开始，提供了AtomicReference类来保证引用对象之间的原子类，你可以把多个变量放在一个对象里来进行CAS操作。所以我们可以使用锁或利用AtomicReference类来把多个共享变量来合并成一个共享变量来操作。

## 4.CAS与synchronized的使用场景

简单的来说CAS适用于写比较少的情况下(多读场景，冲突一般较少)，synchronized适用于写比较多的情况下(多写场景，冲突一般较多)。

1.对于资源竞争较少(线程冲突较轻)的情况，使用synchronized同步锁进行线程阻塞、唤醒切换、用户态内核态间的切换操作，额外浪费CPU资源；而基于CAS基于硬件实现，不需要进入内核态，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。

2.对于资源竞争严重(线程冲突严重)的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。

补充：Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为"**重量级锁**"。但是JAVA1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能开销而引入的**偏向锁**和**轻量级锁**以及其它各种优化之后，在某些情况下并不是那么重了。synchronized的底层实现主要依赖Lock-Free的队列，基本思路是**自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。**在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。