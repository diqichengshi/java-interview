## 1.什么是线程和进程

### 1.1.何为进程

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。

在Java中，当我们启动main函数时其实就是启动了一个JVM的过程，而main函数所在的线程就是这个进程中的一个线程，也成为主线程。

### 1.2.何为线程

线程与进程类似，但线程是一个比进程更小的执行单位。一个进程在其执行过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但是每个线程都有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或者在各个线程之间切换工作时，负担要比进程小的多，也正因为如此，线程也被称为轻量级进行。

Java天生就是多线程程序，我们可以通过JMX来看一下普通Java程序有哪些线程代码如下：

```java
public class MultiThread {
	public static void main(String[] args) {
		// 获取 Java 线程管理 MXBean
	ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
		// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息
		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);
		// 遍历线程信息，仅打印线程 ID 和线程名称信息
		for (ThreadInfo threadInfo : threadInfos) {
			System.out.println("[" + threadInfo.getThreadId() 
                               + "] " + threadInfo.getThreadName());
		}
	}
}
上述程序输出如下
输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可：
[5] Attach Listener //添加事件
[4] Signal Dispatcher // 分发处理给 JVM 信号的线程
[3] Finalizer //调用对象 finalize 方法的线程
[2] Reference Handler //清除 reference 线程
[1] main //main 线程,程序入口
```

从上面的输出内容可以看出：一个Java程序的运行是main线程和多个其他线程同时运行。

## 2.线程与进程的关系，区别及优缺点

### 2.1.图解进行与线程的关系

下图是Java内存区域，通过下图我们从JVM的角度来说一下线程与进程之间的关系。

![img](https://camo.githubusercontent.com/c6fa900b74d490ea8f5e2d4d358c6980f00d45f9/68747470733a2f2f646979636f64652e62302e7570616979756e2e636f6d2f70686f746f2f323031392f66663936666564306532613335346262313662626338346463656466353033612e706e67)

从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区(JDK1.8之后的元空间)资源，但是每个线程都有自己的程序计数器、虚拟机栈和本地方法栈。**

总结：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正好相反。

### 2.2.程序计数器为什么是私有的

程序计数器主要有下面两个作用：

1.字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。

2.在多线程情况下，程序计数器用于记录当前线程执行的位置，从而当线程切换回来的时候能够直到该线程上次执行到哪了。

需要注意的是，如果执行的是native方法，那么程序计数器记录的是undefined，只有执行的是Java代码时程序计数器记录的才是下一条指令的代码。

所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。

### 2.3.虚拟机栈和本地方法栈为什么是私有的

1.**虚拟机栈：**每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，每个方法调用就对应着一个栈帧，在Java虚拟机中入栈和出栈的过程。

2.**本地方法栈：**和虚拟栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机所用到的native方法服务，在HotSpot虚拟机中虚拟机栈和本地方法栈合二为一。

所以，为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

### 2.4.一句话简单了解堆和方法区

堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新的对象(所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

## 3.说说并发与并行的区别

- **并发：** 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；
- **并行：** 单位时间内，多个任务同时执行。

## 4.为什么要使用多线程

先从总体上来说：

- **从计算机底层来说：** 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。
- **从当代互联网发展趋势来说：** 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。

再深入到计算机底层来探讨：

- **单核时代：** 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。
- **多核时代:** 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。

## 5.使用多线程可能会带来什么问题

并发编程的目的就是为了能提高程序的执行效率提高程序的运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁、还有受限于硬件和软件的资源闲置问题。

## 6.说说线程的生命周期和状态

Java线程在运行的生命周期中的指定时刻只可能处于下面6种状态的其中一个

1.new：初始状态，线程被创建，但是还没有调用start()方法。

2.runnable：运行状态，Java线程将操作系统中的就绪和运行两种状态笼统的称为"运行中"。

3.blocked：阻塞状态，表示线程阻塞于锁。

4.waiting：等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)。

5.time_waiting：超时等待，该状态不同于waiting，它是可以在指定的时间自行返回的。

6.terminated：终止状态，表示该线程已经执行完毕。

线程在生命周期中并不是固定处于某一状态而是随着代码的执行在不同状态之间切换。

线程创建之后它将处于NEW(新建)状态，调用start()方法后开始运行，线程这时候处于ready(可运行)状态。可运行状态的线程获得了CPU时间片后就处于running(运行)状态。当线程执行wait()方法后，线程进入wating(等待)状态。run()方法执行之后会进入terminated(终止)状态。

## 7.什么是上下文切换

多线程编程中一般线程的个数都大于CPU核心的个数，而一个CPU核心在任意时刻只能被一个线程使用，为了让这些线程都能有效执行，CPU采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就重新处于就绪状态让其他线程使用，这个过程就属于一次上下文切换。

概括的来说：当前任务在执行完CPU时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。

## 8.什么是线程死锁？如何避免死锁？

### 8.1.认识线程死锁

多个线程同时被阻塞，它们中一个或者全部都在等待某个资源被释放。由于线程被无限期的阻塞，因此程序不可能正常终止。

如下图所示，线程A持有资源2，线程B持有资源1,他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。

![çº¿ç¨æ­»éç¤ºæå¾ ](https://camo.githubusercontent.com/3903a4dc24008be52f72bad23498808b5a743c35/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d342f323031392d34254536254144254242254539253934253831312e706e67)

学过操作系统的同学都应该知道产生死锁的四个必要条件：

1.互斥条件：该资源任意一个时刻只由一个线程占用。

2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。

3.不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。

4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

### 8.2.如何避免线程死锁

我们只要破坏产生死锁的4个条件中的其中一个就可以了。

1.破坏互斥条件：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的(临界资源需要互斥访问)。

2.破坏请求与保持条件：一次性申请所有资源。

3.破坏不剥夺条件：占用部分资源的线程进一步申请其他资源，如果申请不到，可以主动释放它占有的资源。

4.破坏循环等待条件：按某一顺序申请资源，是否资源则反序释放。破坏循环等待条件。

## 9.说说sleep()方法和wait()方法区别和共同点

1.两者最主要的区别在于：**sleep()方法没有释放锁，而wait方法释放了锁。**

2.两者都可以暂停线程的执行。

3.wait()通常被用于线程间交互/通讯，sleep()通常被用于暂停执行。

4.wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。

## 10.为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？

这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！

new一个Thread，线程进入了新建状态；调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。而直接执行run()方法，会把run()当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

**总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。**