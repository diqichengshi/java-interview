
## 1.面向对象和面向过程的区别



### 面向过程

**优点：**性能比面向对象高。因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式、Linux/Unix等一般采用面向过程开发。

**缺点：**没有面向对象容易维护、易复用、易扩展。

### 面向对象

**优点：**易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。

**缺点：**性能比面向过程低。

## 2.Java语言有哪些特点

1.简单易学；

2.面向对象(封装、继承、多态)；

3.平台无关性(Java虚拟机实现平台无关性)；

4.可靠性；

5.安全性；

6.支持多线程(C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而Java语言却提供了多线程支持)；

7.支持网络编程并且很方便(Java语言诞生本身就是为了简化网络编程设计的，因此Java不仅支持网络编程而且很方便)；

8.编译和解释并存；

## 3.关于JVM JDK和JRE最通俗的解释

### JVM

Java虚拟机(JVM)是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现(Windows、Linux、MacOS)，目的是使用相同的字节码，它们都会给出相同的结果。

**什么是字节码？采用字节码的好处是什么？**

在Java中，JVM可以理解的代码就叫做字节码(即扩展名为.class的文件)，它不面向任何特定的处理器，只面向虚拟机。Java语言通过字节码的形式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序在运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无需重新编译便可在多种操作系统的计算机上运行。

**Java程序从源代码到运行一般有下面3步：**

![Javaç¨åºè¿è¡è¿ç¨](https://camo.githubusercontent.com/8f6eceddf64b5948c69a398d1a0e777c9c7f8e5b/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545382542462539302545382541312538432545382542462538372545372541382538422e706e67)

我们需要格外注意的是.class-->机器码这一步。在这一步JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了JIT编译器，而JIT编译器属于运行时编译。当JIT编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接引用。而我们知道，机器码的运行效率肯定是高于Java解释器的。这也解释了我们为什么经常会说Java是编译与解释共存的。

HotSpot采用了惰性评估的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码(热点代码)，而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应的做出一些优化，因此执行的次数越多，它的速度就越快。JDK9引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。但是，AOT编译器的编译质量是肯定比不上JIT编译器的。

总结：Java虚拟机(JVM)是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的JVM实现是Java语言‘一次编译，随处可以运行’的关键所在。

## 4.字符型常量和字符串常量的区别

1.形式上：字符常量是单引号引起的一个字符；字符串常量是双引号引起的若干个字符。

2.含义上：字符常量相当于一个整型值(ASCII值)，可以参加表达式运算；字符串常量代表一个地址值(该字符串在内存中存放的位置)。

3.占内存大小：字符常量只占2个字节；字符串常量占若干个字节(至少一个字符结束标志)(**注意：char在Java中占两个字节**)。

java编程思想第四版：2.2.2节

![img](https://camo.githubusercontent.com/d913ab9b3880feab7d326a0904caac5f5e285a56/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31352f38363733353531392e6a7067)

## 5.构造器constructor是否可被override

在将继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以constructor也就不能被override(重写)，但是可以overload(重载)，所以你可以看到一个类中有多个构造函数的情况。

## 6.重载和重写的区别

**重载：**发生在一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。

**重写：**发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常的范围小于父类，访问修饰符范围大于等于父类；如果父类访问修饰符为private，则子类就不能重写该方法。

## 7.Java面向对象编程三大特性：封装 继承 多态

### 封装

封装吧一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。

### 继承

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性的继承父类。通过使用继承我们能够非常方便的复用以前的代码。

### 多态

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

## 8.String StringBuffer和StringBulider的区别

**可变性**

简单的来说：String类中使用final关键字修饰字符数组来保存字符串，private final char value[]，所以String对象是不可变的。而StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也使用字符数组保存字符串char[] value，但是没有使用final关键字修饰，所以这两种对象都是可变的。

StringBuffer与StringBuilder的构造方法都是调用父类构造方法也就是AbstractStringBuilder实现的大家可以自行查阅源码。

AbstractStringBuilder.java

```java
abstract class AbstractStringBuilder implements Appendable, CharSequence {
    char[] value;
    int count;
    AbstractStringBuilder() {
    }
    AbstractStringBuilder(int capacity) {
        value = new char[capacity];
    }
```

**线程安全性**

String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。

**性能**

每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。StringBuffer每次都会对StingBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StringBuilder相比使用StringBuffer仅能获得10%~15%左右的性能提升，但却要冒多线程不安全的风险。

**对三者使用的总结**

1.操作少量的数据：适用String。

2.单线程操作字符串缓冲区下操作大量数据：适用StringBuilder。

3.多线程操作字符串缓冲区下操作大量数据：适用StringBuffer。

## **9.自动装箱与拆箱**

装箱：将基本数据类型用它们对应的引用类型包装起来。

拆箱：将包装类型转换为基本数据类型。

## 10.在一个静态方法内部调用一个非静态成员变量为什么是非法的？

由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

## 11.Java无参构造函数的作用

Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中的无参构造函数。因此，如果父类中只定义了有参数的构造方法，而子类在构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法就是在父类里加上一个不做事且没有参数的构造方法。

## 12.接口和抽象类的区别是什么

1.接口的方法默认是public，所有方法在接口中不能有实现(Java8开始接口方法可以有默认实现)，而抽象类可以有非抽象的方法。

2.接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。

3.一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。

4.接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符(抽象方法就是为了被重写所以不能使用private关键字修饰)。

5.从设计层面上说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

## 12.成员变量和局部变量的区别有哪些

1.从语法形式上看：成员变量属于类，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public、private、static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰。

2.从变量在内存中的存储方式来看：如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量存在于栈内存。

3.从变量在内存中的生存时间上看：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。

4.成员变量如果没有被赋初值：则会自动以类型的默认值而赋值(一种情况例如被final修饰的成员变量也必须显式的赋值)，而局部变量则不会自动赋值。

## 13.==与equals(重要)

1.==是判断两个变量或实例是不是指向同一个内存空间，equals()是判断两个变量或实例所指向的内存空间的值是不是相同。

2.==是指对内存地址进行比较，equals()是对字符串的内容进行比较。

3.==指引用是否相同，equals()指的是值是否相同。

**举个例子：**

```java
public class test1 {
    public static void main(String[] args) {
        String a = new String("ab"); // a 为一个引用
        String b = new String("ab"); // b为另一个引用,对象的内容一样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if (aa == bb) // true
            System.out.println("aa==bb");
        if (a == b) // false，非同一对象
            System.out.println("a==b");
        if (a.equals(b)) // true
            System.out.println("aEQb");
        if (42 == 42.0) { // true
            System.out.println("true");
        }
    }
}
```

**说明**：

1.String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。

2.当创建String类型的对象时，虚拟机会在常量池中产找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋值给当前引用。如果没有就在常量池中重新创建一个String对象。

## 14.hashCode与equals(重要)

面试官可能会问你：”你重写过hashCode和equals么，为什么重写时必须重写hashCode方法？“

**hashCode()介绍**

hashCode()的作用是获取哈希码，也称为散列表；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在JDK的Object.java中，这就意味着Java中任何类都包含有hashCode()函数。

散列表存储的是键值对(key-value)，它的特点是：能根据键快速的检索出对应的值。这其中就利用了散列码！(可以快速找到所需要的对象)。

**为什么要有hashCode**

**我们先以”HashSet如何检查重复“为例子来说明为什么要有hashCode：**当你把对象加入HashSet时，HashSet会先计算对象的hashCode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashCode值做比较，如果没有相符的hashCode，HashSet会假设对象没有重复出现。但是如果发现有相同hashCode值的对象，这是会调用equals()方法来检查hashCode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。

通过上文我们可以看出：hashCode()的作用是获取**哈希码**，也就是散列码；它实际上是返回一个int整数。**这个哈希码的作用**是确定该对象在哈希表中的索引位置。hashCode()在散列表中才有用，在其他情况下没用。在散列表中hashCode()的作用是获取对象的散列码，进而确定该对象在散列表中的位置。

**hashCode()与equals()的相关规定**

1.如果两个对象相等，则hashCode一定也是相同的。

2.两个对象相等，对两个对象分别调用equals方法都返回true。

3.两个对象有相同的hashCode值，它们也不一定是相等的。

4.因此，equals()方法被覆盖过，则hashCode方法也必须被覆盖。

5.hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等(即使这两个对象指向相同的数据)。

推荐阅读：[Java hashCode() 和 equals()的若干问题解答](https://www.cnblogs.com/skywang12345/p/3324958.html)

