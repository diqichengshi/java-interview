## 写在前面(常见面试题)

### 基本问题

- **介绍下 Java 内存区域（运行时数据区）**
- **Java对象的创建过程(五步，建议能默写出来并且要知道每一步虚拟机做了什么)**
- **对象的访问定位的两种方式(句柄和直接指针两种方式)**

### 扩展问题

- **String类和常量池**
- **8种基本类型的包装类和常量池**

## 1.概念

对于Java程序员来说，在虚拟机自动管理内存的机制下，不再需要像C/C++程序开发人员这样为了一个new操作去写对应的delete/free操作，不容易出现内存泄漏和内存溢出问题。正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。

## 2.运行时数据区域

Java虚拟机在执行Java程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK1.8和之前版本略有不同。下面会介绍到。

**JDK1.8之前：**

![img](https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67)

**JDK1.8:**

![img](https://camo.githubusercontent.com/0bcc6c01a919b175827f0d5540aeec115df6c001/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d334a617661e8bf90e8a18ce697b6e695b0e68daee58cbae59f9f4a444b312e382e706e67)

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区
- 直接内存 (非运行时数据区的一部分)

### 2.1.程序计数器

程序计数器是一块较小的内存区域，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**

另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储，我们称这类内存区域为"线程私有"的内存。**

**从上面的介绍中我们知道程序计数器主要有两个作用：**

1.字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。

2.在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了。

**注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**

### 2.2.Java虚拟机栈(重点)

**与程序计数器一样，Java虚拟机栈也是线程私有的，它生命周期和线程相同，描述的是Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的。**

**Java**内存可以粗糙的分为堆内存(Heap)和栈内存(Stack)，其中栈就是我们说的虚拟机栈，或者说是虚拟机栈中局部变量表部分(实际上，<u>**Java虚拟机是由一个个栈帧组成，每个栈帧中都有：局部变量表、操作数栈、方法出口信息、动态链接**</u>)。

**局部变量表主要存放了编译器可知的各种数据类型**(boolean、byte、char、short、int、float、long、double)、**对象引用**(reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表的句柄或者其他与此对象相关的位置)。

**Java虚拟机栈会出现两种异常：StackOverFlowError和OutOfMemoryError。**

- **StackOverFlowError：**若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过了当前Java虚拟机栈的最大深度的时候，就会抛出StackOverFlowError异常。
- **OutOfMemoryError：**若Java虚拟机的栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。

Java虚拟机栈也是线程私有的，每个线程有自己的虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。

**扩展：那么方法函数怎么调用？**

Java虚拟机栈类比数据结构中栈，**Java虚拟机栈保存的主要是栈帧**，每一个函数调用都有一个对应的栈帧被压入栈，每一个函数调用结束后，都会有一个栈帧被弹出。

Java方法的两种返回方式：

1.return语句。

2.抛出异常。

不管哪种返回方式都会导致栈帧被弹出。

### 2.3.本地方法栈(理解)

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的**局部变量表、操作数栈、出口信息、动态链接**。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

### 2.4.堆(重点)

Java虚拟机所管理的内存中最大的一块，Java堆是所有线程共享的一块内存区域，在虚拟机启动的时候创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都是在这里分配内存。**

Jav堆是垃圾收集器管理的主要区域，因此也被称为GC堆(Carbage Collected Heap)。从垃圾回收的角度，由于现在收集器基本上都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：eden空间、From Survivor、To Survivor空间等。**进一步划分的目的是更好的回收内存，或者更快的回收内存。**

![img](https://camo.githubusercontent.com/4012482f49926b35d8557b63952ee605fd259f62/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d33e5a086e7bb93e69e842e706e67)

上图所示的eden区、s0区、s1区都属于新生代，tentired区属于老年代。大部分情况，对象都会首先在Eden区域分配，在新生代垃圾回收后，如果对象还存活，则会进入s0或者s1，并且对象的年龄还会加1(Eden区-->Survivor区后对象的初始年龄变为1)，当它的年龄增加的一定程度(**默认15次Minor GC**)，就会被晋升到老年代中。对象晋升到老年代的阈值，可以通过参数`-XX:MaxTenuringThreshold` 来设置。

### 2.5.方法区

方法区和堆一样，是各个线程共享的内存区域，它用于存储**已被虚拟机加载的类信息、常量(保存在常量池中)、静态变量、即时编译器编译后的代码**等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但它却有一个别名**Non-Heap(非堆)**，目的应该是与Java堆区分开。

方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。

#### 2.5.1.方法区和永久代的关系

《Java 虚拟机规范》只是规定了有方法区这个概念和它的作用，并没有规定如何去实现它。那么，在不同的JVM上方法区的实现肯定是不同的了。**方法区和永久代的关系很像Java接口中接口与类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中的方法区的一种实现方式。**也就是说，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

#### 2.5.2.为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢？

整个永久代有一个JVM本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会的得到java.lang.OutOfMemoryError。你可以使用`-XX：MaxMetaspaceSize` 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。`-XX：MetaspaceSize` 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

当然这只是其中一个原因，还有很多底层的原因，这里就不提了。

### 2.6运行时常量池

运行时常量池是方法区的一部分。**主要用于存放已经编译在Class文件中的常量。**Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息(用于存放编译器生成的各种字面量(实际值)和符号引用)。

既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

## 3.HotSpot虚拟机对象探秘

通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。

### 3.1.对象的创建

下图便是Java对象的创建过程，建议最好是能默写出来，并且掌握每一步在做什么。

![Java å¯¹è±¡çåå»ºè¿ç¨ ](https://camo.githubusercontent.com/e99480df412dd718430d78094143a5485c908fa7/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f32322f313635363165353961343133353836393f773d39353026683d32373926663d706e6726733d3238353239)

#### 3.1.1.Step1：类加载检查

虚拟机遇到一条new指令时，首先将去检查	这个指令的参数能否在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析过、初始化过。如果没有，那必须执行相应的类加载过程。

#### 3.1.2.Step2：分配内存

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定大小，为类分配内存空间的任务等同于把一块确定大小的内存从Java堆中划分出来。分配方式有"**指针碰撞**"和"**空闲列表**"两种，**那么选择哪种分配方式由Java堆是否规整决定，而Java是否规整又由所采用的垃圾回收器是否带有压缩功能来决定。**

**内存分配的两种方式(补充内容，需要掌握)**

选择以上两种方式的哪一种，取决于Java堆内存是否规整。而Java对是否规整，取决于GC收集器的算法是"标记-清除"，还是"标记-整理"(也称作"标记-压缩")，值得注意的是，复制算法内存也是规整的。

![img](https://camo.githubusercontent.com/65fc0c035f1f70081f4dcdd113c3b2c7aa931a2a/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f382f32322f313635363165353961343061326333643f773d3134323626683d33333326663d706e6726733d3236333436)

**内存分配的并发问题(补充内容，需要掌握)**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很繁琐的事情，作为虚拟机来说，必须要保证是线程安全的，通常的讲，虚拟机采用两种方式来保证线程安全。

- **CAS+重试机制：**CAS是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果冲突失败就重试，直到成功为止。**虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。**
- **TLAB：**为每一个线程预先在Eden区分配一块内存，JVM在给线程中的对象进行内存分配时，首先在TLAB分配，当对象大于TLAB中剩余内存或TLAB的内存已用尽时，采用上述的CAS进行内存分配。

#### 3.1.3.Step3：初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

#### 3.1.4.Step4：设置对象头

初始化完成之后，**虚拟机要对对象进行一些必要的设置**，例如**这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等。这些信息存放在对象头中**。另外，根据虚拟机的当前允许状态的不同，如是否开启偏向锁等，对象头会有不同的设置方式。

#### 3.1.5.Step5：执行init方法

在上面的工作完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行new指令之后会接着执行<init> 方法，把对象按照程序员的意图进行初始化，这样一个真正可用的对象才算完全产生出来。

### 3.2.对象的内存布局

在HotSpot虚拟机中，对象在内存中的布局可以分为3块区域：**对象头、实例数据、对齐填充。**

**HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据**(哈希码、GC分代年龄、锁状态标志等等)，另一部分是**类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。

**对齐填充部分不是必然存在的，也没有什么特别的含义仅仅起到占位作用**。因为HotSpot虚拟机的自动内存管理系统要求对象的起始位置必须是8字节的整数倍，话句话说对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数(1倍或2倍)，因此，当对象实例数据部分没有对齐时，就需要通过对其填充来补全。

### 3.3.对象的访问定位

建立对象就是为了使用对象，我们的Java程序通过栈上的reference数据来操作堆上的具体对象。对象的访问方式由虚拟机的实现而定，目前主流的访问方式有**①使用句柄**和**②直接指针**两种：

1.**句柄：**如果使用句柄的话，那么Java堆中将会划出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

![ä½¿ç¨å¥æ ](https://camo.githubusercontent.com/5923998f8408ea936a0416291faf1b2a1d215108/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f32372f313633303662393537333936383934363f773d37383626683d33363226663d706e6726733d313039323031)

2.**直接指针：**如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。

![ä½¿ç¨ç´æ¥æé ](https://camo.githubusercontent.com/af3d3845b1d5d9c1927e77f79d2cb96ea84090fe/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f342f32372f313633303662613361343162366236353f773d37363626683d33353326663d706e6726733d3939313732)

这两种对象的访问方式各有优势。使用句柄带来的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。使用直接指针访问方式的最大好处就是速度快，它节省了一次指针定位的时间开销。

## 4.重点补充内容

### 4.1.String类和常量池

**String创建对象的两种方式：**

```java
//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，
//然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"abcd""；
String str1 = "abcd";
String str2 = new String("abcd");//堆中创建一个新的对象
String str3 = new String("abcd");//堆中创建一个新的对象
System.out.println(str1==str2);//false
System.out.println(str2==str3);//false
```

这两种不同的创建方法是有差别的。

- 第一种方式是在常量池中拿对象；
- 第二种方式是直接在堆内存空间创建一个新的对象。

记住一点：**只要使用new方法，便需要创建新的对象。**

**String类型的常量池比较特殊。它的主要使用方法有两种：**

- 直接使用双引号声明出来的String对象会直接存储在常量池中。
- 如果不是用双引号声明的String对象，可以使用String提供的intern()方法。String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含了一个此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。

```java
String s1 = new String("计算机");
String s2 = s1.intern();
String s3 = "计算机";
System.out.println(s2);//计算机
System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象
System.out.println(s3 == s2);//true，因为两个都是常量池中的 String 对象
```

### 4.2.String s1 = new String("abc");这句话创建了几个字符串对象

将创建1或2个字符串。如果池中已存在字符串文字"abc"，则吃中只会创建一个字符串"s1"。如果池中没有字符串文字"abc"，那么它将首先在池中创建，然后在堆空间中创建，因此总共创建2个对象。

```java
String s1 = new String("abc");// 堆内存的地址值
String s2 = "abc";
System.out.println(s1 == s2);// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。
System.out.println(s1.equals(s2));// 输出 true

```

### 4.3.八种基本类型的包装类和常量池

- **Java基本类型的包装类的大部分都实现了常量池技术，Byte,Short,Integer,Long,Character,Boolean；这5种包装类型默认创建了数值[-128,127]的相应类型的缓存数据，但是超出此范围仍然去创建新的对象。**
- **两个浮点类型的包装类Float,Double并没有实现常量池技术。**

```java
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true
Integer i11 = 333;
Integer i22 = 333;
System.out.println(i11 == i22);// 输出 false
Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false
```

**Integer 缓存源代码：**

```java
/**
*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。
*/
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

**应用场景**

1. Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。
2. Integer i1 = new Integer(40);这种情况下会创建新的对象。

```java
Integer i1 = 40;
Integer i2 = new Integer(40);
System.out.println(i1==i2);//输出 false
```

**Integer 比较更丰富的一个例子:**

```java
Integer i1 = 40;
Integer i2 = 40;
Integer i3 = 0;
Integer i4 = new Integer(40);
Integer i5 = new Integer(40);
Integer i6 = new Integer(0);

System.out.println("i1=i2   " + (i1 == i2)); //true
System.out.println("i1=i2+i3   " + (i1 == i2 + i3)); //true
System.out.println("i1=i4   " + (i1 == i4)); //false
System.out.println("i4=i5   " + (i4 == i5)); //false
System.out.println("i4=i5+i6   " + (i4 == i5 + i6));  //true  
System.out.println("40=i5+i6   " + (40 == i5 + i6));  //true  
```